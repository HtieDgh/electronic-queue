/* Main.c file generated by New Project wizard
 *
 * Created:   Ср сен 17 2025
 * Processor: AT89C51
 * Compiler:  SDCC for 8051
 */

#include <mcs51reg.h>
#include <stdint.h>
#include <serial_IO.h>//putchar() и getchar() с UART интерфейсом (по умолчанию 62500 Baud rate)

//////////////////////////////////////////////////////////////////////////
//Константы
	#define QUEUE_SIZE 40	//кол-во элементов в очереди
	#define WORKERS_SIZE 8//Макс количество операторов
	#define CATEGORY_SIZE 8 //Макс количество категорий


//////////////////////////////////////////////////////////////////////////
//Глобальные переменные
	__idata char vtin;  	   	// Веденный символ от Virtual Terminal
	__idata uint8_t LEDreg;    	// Состояние индикаторов клиента в очереди на рабочем месте оператора. Оно будет сдвинуто в регистр при обновлении очереди.
	__idata uint8_t LED2reg;
	__idata uint8_t LEDmask;	// Маска для состояний, которая позволяет зажечь определенный индикатор, используется в LEDgetMask
	__idata uint8_t i1;// Простые итераторы для for циклов. Они общие для всех функций, так как нельзя объявлять итератор в for(int i;...) секции
	__idata uint8_t i2;
	__idata uint8_t keyCode;	//Декодированный номер рабочего места оператора
	

// Строки для пользователей
	__idata uint8_t sind; //индекс текущего символа в строках
	__code char sWelcome[] = "Choose category of service:\r";
	__code char sYNumIs[] = "Your num is ";
	__code char sEnterCat[] = "Enter category num -> ";
	__code char sEnterSign[] = " -> ";
	__code char sAdmEnterWorkers[] = "Enter workers <id> -> <catName>\r";
	__code char sAdmWrongCatName[] = "Wrong Category Name\r";
	__code char sWrongNum[] = "Wrong Number\r";
	__code char sGotoWindow[] = " >>> ";
	__code char sSetCallMethod[] = "Set client delayed call method?\r(y/n) -> ";
	__code char sThereIsCatWithoutW[] = "There is Category without worker, try again\r";
	//Строки ниже имеют макс размер = 16-5-4-1-1 = 5 символов
	__code char sStatus[4][12]={
		" waiting",
		" processing",
		" done",
		" canceled"
	};

	// Буфер для хранения строк дисплея
	__idata char sLineBuffer[17]="                "; //изменяемая строка для отправки на интерфейсы
	__idata uint8_t lcdLineNum;

	////////////////////////////////////////////////////////////////////////////////////////////////
	// Таблица категории. Хранит кол-во заявок, id категории и соответствующий ей идентификатор в формате ascii 
		typedef struct
		{
			uint8_t count;		// кол-во Заявок в данной категории
			char name; 			// Идентификатор категории он же
								// ее символ в очереди в формате ascii в имени позиции: X01
								//                                            			^
		} CT;
		CT CategoryTable[CATEGORY_SIZE]; //id категории = индексу в массиве
		__idata uint8_t catCount; // ограничивает текущее кол-во категорий в системе

		//добавить имя к категории
		#define CsetName(in,id) CategoryTable[id].name=in

		//повысить текущий номер в категории
		#define Cinc(id) CategoryTable[id].count++

		//Получить имя категории
		#define CgetName(id) CategoryTable[id].name

		//Получить кол-во когда заявок в категории
		#define CgetCount(id) CategoryTable[id].count

		//поиск id категории по его имени
		uint8_t CgetID(char catName){
			for(i2=0;i2<catCount;i2++){ //поиск id категории 
				if(CgetName(i2)==catName) break;
			}
			return i2;
		}

		//Перевод кол-ва заявок в номер идентификатора
		void queue_elem_to_ascii(uint8_t clientInfo, uint8_t ClientNum){
			uint8_t tmp = ClientNum;
			sLineBuffer[4]='\0';
			sLineBuffer[3] = tmp % 10 + 0x30;
			tmp/=10;
			sLineBuffer[2] = tmp % 10 + 0x30;
			tmp/=10;
			sLineBuffer[1] = tmp % 10 + 0x30;
			sLineBuffer[0] = CgetName( (clientInfo >> 2) & 0x07 );	//первый символ идентификатора - имя (символ) категории
		}

		
	//////////////////////////////////////////////////////////////////////////
	// Таблица позиций в очереди
		typedef struct{
			uint8_t info;// здесь закодированы биты: id рабочего места | id категории | код состояния (0 ожидает, 1 в обработке, 2 обработан, 3 отменен)
						 //					  		nnn|ccc|ss
			uint8_t num; //id в рамках категории
		} Qelem;
		typedef struct
		{
			
			Qelem el[QUEUE_SIZE];
			uint8_t head; //указатели очереди
			uint8_t tail;
			uint8_t count;
		} QT;
		__idata QT QueueTable;
		__idata Qelem elem; //буфер для чтения/записи очереди

		// Инициализация/очистка очереди
		void queue_init(QT *q) {
			q->head = 0;
			q->tail = -1;
			q->count = 0;
		}

		//Проверка на полноту
		uint8_t queue_is_full(QT *q) {
			return q->count == QUEUE_SIZE;
		}

		// Добавление элемента в очередь с вытеснением старых 
		void queue_push(QT *q) {
			if (queue_is_full(q)) {
				//Очередь полная
				//Переместить head, тем самым "удаляя" самый старый элемент
				q->head = ( (uint8_t)(q->head + 1) )% QUEUE_SIZE;
				q->count--;
			}
			
			// Добавить новый элемент
			q->tail =( (uint8_t)( q->tail + 1 ) )% QUEUE_SIZE;
			q->el[q->tail].info = elem.info;
			q->el[q->tail].num = elem.num;
			q->count++;
		}
		
		__idata uint8_t pos;
		
		// Получение элемента по индексу (0 - самый старый (первый в очереди), count-1 - самый новый (последний в очереди))
		uint8_t queue_seek(QT *q, const uint8_t index)
		{
			if (index >= q->count) {
				return 0;
			}
			pos = ((uint8_t)(q->head + index)) % QUEUE_SIZE;
			elem.info = q->el[pos].info;
			elem.num = q->el[pos].num;
			return 1;
		}
		
		//Регистрация клиента в очереди
		void register_in_queue(uint8_t catID) {
			elem.info=catID<<2;
			Cinc(vtin);  	  //повысить номер категории
			elem.num=CgetCount(catID);
			queue_push( &QueueTable );
			
		}

		// Ищет клиента в очереди с заданными полями. Возвращает 0=false если такого клиента нет
		// i1 - номер q->el[id] 
		// elem = значения 
		// true/false - найден не найден
		uint8_t queue_find(uint8_t workerID, uint8_t catID, uint8_t sts )
		{
			i1=-1;
			workerID = (workerID<<5) | catID<<2 | sts;

			while (queue_seek(&QueueTable, ++i1))
			{
				if( elem.info == workerID)
				{
					return 1;
				}
			}
			return 0;
		}
		/////////////////////////////////////////////////////////////////////
		// Таблица рабочих мест операторов. Хранит информацию о том какую категорию обслуживает оператор
		// структура *W: XXXX XXXX
		//				 ^	  		рабочее место активно
		//                ^			Оператор рабочего места обрабатывает в данный момент Клиента
		// 				       ^^^  id категории этого рабочего места
		__idata uint8_t WorkerTable[WORKERS_SIZE]; //id рабочего места = индексу в массиве

		//Таблица результатов запросов, на выборку различных данных из категорий и рабочих мест
		__idata uint8_t Res[WORKERS_SIZE];
		
		//получить ID категории  рабочего места по его ID 
		#define WgetCatID(id) WorkerTable[id] & 0x07
		//Проверка активности рабочего места
		#define WisActive(id) WorkerTable[id] & 0x80
		//Проверка занятости рабочего места
		#define WisBusy(id) WorkerTable[id] & 0x40

		// Получить id всех рабочих мест заданной категории. Возвращает количество найденных мест
		uint8_t find_all_workers(const uint8_t catID){
			i2=0;
			for( i1=0; i1< WORKERS_SIZE; i1++ ){
				if(WisActive(i1)){// Если оно активно
					if(	(WgetCatID(i1)) == catID )// и категория рабочего места равна заданной
					{
						Res[i2++] = i1;		  // то добавить идентификатор рабочего места в результат
					}
				}
			}
			return i2;	//вернуть кол-во рабочих мест
		}
		
/////////////////////////////////////////////////////////////////////////
// Состояния конечного автомата, для обработки сигналов от VT
	typedef enum{
		F,
		WELCOME,HISTORY,
		YNUMIS,CLIENTNUM,CLIENTACK,PRINTSERVICES,WRONGNUMBER
	} Automata;
	__idata Automata KA;

/////////////////////////////////////////////////////////////////////////
//Взаимодействие с LED
	//Схема подключения led регистра сдвига
	#define LEDD P1_4
	#define LEDCLK P1_5
	#define LEDRST P1_6
	#define LEDST P1_7
	#define LED2CH P3_7 //выбор второго led

	//Устанавливает состояние индикаторов на рабочих местах операторов
	void LED_reload(uint8_t reg, __bit led2ch) __critical
	{
		LEDCLK=0;
		LED2CH=led2ch;
		if(led2ch){
			LED2reg = reg;
		}else{
			LEDreg = reg;
		}
		for(i1 = 0;i1<8;++i1){
			LEDD = reg & 0x80;
			reg<<=1;
			LEDCLK=1;
			LEDCLK=0;
		}
		LEDST=1;
		LEDST=0;
	}
	
	//Возвращает маску для зажигания лампы индикатора рабочего места по его id
	#define LEDgetMask(workerID) (((0xFE) << ((workerID) & 7)) | ((0xFE) >> (8 - ((workerID) & 7))))

///////////////////////////////////////////////////////////////////////////////
//Взаимодействие с UART

	// Печать след символа на vt вызывая прерывание uart
	#define vt_write(c) SBUF = c

	// Чтение символа с vt вызывая прерывание uart
	#define vt_read(c) c = SBUF

	// Печать строки вызывая прерывание uart
	// Печать очередного символа и смена состояния КА в случае когда последний символ был напечатан
	void vt_print(char* str, Automata nextState, __bit isMove)
	{
		if(str[sind]!='\0'){
				vt_write(str[sind++]);
		}else{
			//строка выведена, переход на след состояние
			KA = nextState;
			sind = 0;
			if(isMove){ 
				TI=1;
			}
		}
	}

	// Печать строки на uart без прерываний
	void putstring(char* str) __critical
	{
		while(str[sind]!='\0'){//вывод символа ввода
			putchar(str[sind++]);
		}
		sind=0;
	}

	// Вывести на uart все доступные для выбора категории без прерываний
	void vt_write_categories() __critical
	{
		for(i1=0;i1<catCount;i1++)
		{
			putchar(CgetName(i1));
			putstring(sEnterSign);
			putchar(i1+0x30);
			putchar(' ');
			putchar(' ');
			if(i1%2)//разделить на 2 колонки чтоб категории вместились на экран
			{ 
				putchar('\r');
			}
		}
		putchar('\r');
	}

	//Очистка экрана uart без прерываний
	void vt_clrscr() __critical
	{
		uint8_t tmp=0;
		for(tmp=0;tmp<255;tmp++){
			putchar('\x8');
		}
	}
/////////////////////////////////////////////////////////////////////////
//Взаимодействие с HD4478
	void lcd_init();
	void lcd_send(char btsend);
	void lcd_command(char btsend);
	void lcd_data(char btsend);
	uint8_t lcd_check();
	#define LCD_MORE(b) lcd_send(b)

	//Схема подключения
	#define lcd_port P2		//порт P2 - Данные для lcd дисплея 
	#define BF P2_7
	#define RS P3_4	
	#define RW P3_5
	#define E P3_6	

	//адреса для линий
	#define LCD_LINES_SIZE 0x04
	#define LCD_LINE1 0x00
	#define LCD_LINE2 0x40
	#define LCD_LINE3 0x10
	#define LCD_LINE4 0x50

	// Установка позиции курсора
	void lcd_set_cursor(const uint8_t line, const uint8_t pos) {
		uint8_t address;
		
		switch(line) {
			case 0: address = LCD_LINE1; break;
			case 1: address = LCD_LINE2; break;
			case 2: address = LCD_LINE3; break;
			case 3: address = LCD_LINE4; break;
			default: address = LCD_LINE1;
		}
		
		lcd_command(0x80 | (address + pos));
	}
	//Печать строки на lcd. __critical запрещает прерывания во время выполнения функции
	void lcd_print(const char* str) __critical
	{
		lcd_data(str[sind++]);
		while (str[sind]!='\0')
		{
			LCD_MORE( str[sind++] ); //Отправка символов на lcd
		}
		sind = 0;
	}
	//Добавляет строку на LCD
	void lcd_add_line(const char *new_line)
	{
		if( ++lcdLineNum == LCD_LINES_SIZE )
		{
			lcd_command(1);//очистка экрана
			lcdLineNum=0;
			while (lcd_check());//ожидание конца выполнения очистки			
		}
		// Смена строки
		lcd_set_cursor( lcdLineNum, 0);
		//печать строки
		lcd_print(new_line);
	}
	// Инициализация ЖКИ
	void lcd_init()
	{
		E = 0;
		lcd_port = 0;
		lcd_command(0x38); //установка dl на 1 (8 бит) n = 1 (2 строки) f = 0 5х8 символов

		LCD_MORE(0b00001100); //Команда 00001110 (D = 1 Включить дисплей, C = 0 курсор выкл )

		LCD_MORE(0b110);//команда 00000110 (ID = 1 Инкремент при записи S = 0 Окно при записи не сдвигается)
		LCD_MORE(1);	//очистка экрана
		lcdLineNum=-1;
		while (lcd_check());//ожидание конца выполнения очистки
	}

	//Задержка после отправки. __naked упрощает накладные расходы на вызов функции [SDCC manual, p 49]
	void lcd_delay()
	{
		i1 = 40;
		for(;i1>0;--i1);
	}

	// Код отправки
	void lcd_send(const char btsend)
	{
		lcd_port = btsend;
		E = 1;
		lcd_delay();
		E = 0;
	}

	// Отправить данные (символ)
	void lcd_data(const char btsend){
		RS = 1;
		RW = 0;
		lcd_send(btsend);
	}

	// Отправить команду
	void lcd_command(const char btsend){
		RS = 0; 
		RW = 0; 
		lcd_send(btsend);
	}

	// Проверить состояние дисплея. Возвращает флаг BF
	uint8_t lcd_check(void){
		uint8_t busy_flag;
		RS=0;
		RW=1;
		
		lcd_port = 0xFF;  // Для 8051 - установка в 1 делает порт входом
		
		// Послать короткий сигнал
		E = 1;
		__asm
			nop
			nop
		__endasm; // Короткая задержка
		busy_flag = lcd_port;      // читать данные
		E = 0;
		
		// BF находится в старшем бите (bit 7)
		return (busy_flag & 0x80);
	}

//////////////////////////////////////////////////////////////////////////////
/*
	Схема рабочих место операторов:
	Код клавиши P1[3..1]; № рабочего места; сигнал;
		0-7;  0-7; подтвердить;
		8-15; 0-7; отменить;

	Прочие кнопки; действие;
		P3.2; приостановить работу очереди и показать историю обработок
		P3.3; оператор нажал на кнопку, GS у шифратора отвечает за сигнал нажатия кнопки оператора
*/
// хранит метод вызова клиента (моментальный / с задержкой)
__bit clCallMethod;
__bit WNotInitialised;

//Инициализация БД в начале работы
void init_db(){
	char tmp=0;
	// Вызывать клиентов с задержкой?
	putstring(sSetCallMethod);
	vtin=getchar();
	putchar(vtin); putchar('\r');
    clCallMethod = (vtin == 'y');

	// Инициализация Категорий
	do{
		// вывод фразы для ввода кол-ва категорий
		putstring(sEnterCat);

		// ввод количества категорий
		vtin = getchar();
		catCount = vtin-0x30;
		if(catCount > CATEGORY_SIZE){
			putstring(sWrongNum);
		}else{
			break;
		}
	}while(1);
	
	putchar(vtin); 	
	putchar('\r');
	for(i1=0;i1<catCount;i1++)
	{
		putchar(i1+0x30);//вывод текущего индекса категории

		putstring(sEnterSign);
		vtin=getchar();
		if( CgetID(vtin) != catCount){ // Проверка на уникальность имени Категории
			putstring(sAdmWrongCatName); // Если такое имя уже есть, то назначать работнику ее нельзя
			i1--;
			continue;
		}
		CategoryTable[i1].name=vtin;//ввод имени категории в бд
		CategoryTable[i1].count=0;  //обнуление после reset
		putchar(vtin); 
		putchar('\r');
	}
	//Инициализация рабочих мест
	do
	{
		tmp=0;
		WNotInitialised=0;
		putstring(sAdmEnterWorkers);

		for(i1=0;i1<WORKERS_SIZE;i1++)
		{
			putchar(i1+0x30);//вывод номера рабочего места
			putstring(sEnterSign);

			vtin=getchar();
			WorkerTable[i1] = 0;//обнуление после reset
			if(vtin!='='){
				WorkerTable[i1] = CgetID(vtin);

				if(WorkerTable[i1] == catCount){//если такой категории не существует, то	
					putstring(sAdmWrongCatName);//вывод сообщения и повтор инициализации текущего рабочего места
					i1--;
					continue;
				}
				WorkerTable[i1] |= 0x80;	//установка активного статуса рабочего места
			}
			putchar(vtin);
			putchar('\r');
		}
		
		for(; tmp<catCount; tmp++){
			if(find_all_workers(tmp)==0){
				WNotInitialised=1;
				vt_clrscr();
				putstring(sThereIsCatWithoutW);
			}
		}
	} while (WNotInitialised);
	
	queue_init(&QueueTable);		 //инициализация очереди
}


void main(void)
{ 
//INIT
	sind = 0;		 // индекс текущего символа в строках
	lcd_init(); 	 // Инициализировать дисплей
	lcd_command(0b11000000);
	while(lcd_check());
	EX1 = 1;		 // Разрешить int1
	EX0 = 1;  		 // Разрешить int0
	IT1 = 1;		 // прерывания только по заднему фронту
	IT0 = 1;		 
	ES = 1;     	 // Разрешить прерывания от UART
	P1 = 0b01001111; // Кнопки
	LED_reload(0xFF,0); //Выключить все лампочки
	LED_reload(0xFF,1);

	KA = WELCOME;	 // Начальное состояние автомата
	// Инициализация таймера 1 режим 1 62500 baud
	inituart(0xFF);  // Эта функция из библиотеки устанавливает флаг TI что в случае EA = 1 вызывает прерывание uart
	
	vt_clrscr();	 //очистка экрана после инициализации БД
	init_db();       //инициализация БД
	vt_clrscr();     //очистка экрана после инициализации БД
	
	EA=1;	         //Активация перываний 

	while (1);       //конец программы, активное ожидание событий-прерываний
}

//////////////////////////////////////////////////////////////////////////////
// Обработка прерываний
// Прерывание int0, Остановить работу системы и выдать историю очереди на экран virtual terminal
void adm_pause() __interrupt(0)  __critical
{
	char tmp = QueueTable.count;
	lcd_delay();
	IE0=0;
	TI=1;//этот сигнал нужен для выполнения putchar(), getchar()
	vt_clrscr();//очистка экрана перед выводом истории
	
	i2=0;
	while (i2<QueueTable.count)
	{
		queue_seek(&QueueTable, i2);
		queue_elem_to_ascii( elem.info, elem.num );
		putstring(sLineBuffer);
		putstring(sGotoWindow);
		putchar(
			( (elem.info>>5) & 7 ) + 0x30
		);

		//вывод статуса
		putstring(sStatus[elem.info & 3]);
		putchar('\r');
		i2++;
	}
	getchar();//ожидание подтверждения от администратора
	//очистка после вывода истории
	
	for(; tmp>0; tmp-=10){
		vt_clrscr();
	}

	KA=WELCOME;//продолжение работы (вызов прерывания)
}
// Зажигает индикатор занятости у работника
void led_busy_up(const uint8_t workerID)
{
	LEDmask=LED2reg;
	LEDmask &= LEDgetMask(workerID);
	LED_reload(LEDmask,1);
}
// Гасит индикатор занятости у работника
void led_busy_down(const uint8_t workerID)
{
	LEDmask=LED2reg;
	LEDmask |= ~(LEDgetMask(workerID));
	LED_reload(LEDmask,1);
}
//Позвать клиента сразу по его id в очереди (талону).
void lcd_client_call(uint8_t queueId, uint8_t workerId)
{
	queue_elem_to_ascii( QueueTable.el[queueId].info, QueueTable.el[queueId].num );
		queueId=4;
		while (sGotoWindow[sind])
		{
			sLineBuffer[queueId++]=sGotoWindow[sind++];
		}
		sLineBuffer[queueId++] = workerId + 0x30;
		sLineBuffer[queueId]='\0';
		sind=0;
	//Вывести талон на lcd
	lcd_add_line(sLineBuffer);
}

// Очищает экран lcd и выводит на lcd первые 4 талона клиентов у которых статус "в обработке"
void lcd_print_first_four_clients()
{
	uint8_t i3;
	uint8_t i4;
	if(lcdLineNum==3) return;//Если lcd уже заполнен, то вызывать пока никого не надо
	i2=0;

	lcd_command(1);//очистка экрана
	lcdLineNum=-1;
	while (lcd_check());//ожидание конца выполнения очистки

	for(i4=0;i4<4;i4++)
	{
		while (1)
		{
			if( !queue_seek( &QueueTable, i2++ ) ){
				return;
			}
			if((elem.info & 0x3) == 1){ break; }
		}
		queue_elem_to_ascii( elem.info, elem.num );
		i3=4;
		while (sGotoWindow[sind])
		{
			sLineBuffer[i3++]=sGotoWindow[sind++];
		}
		sLineBuffer[i3++] = (elem.info>>5) + 0x30;
		sLineBuffer[i3]='\0';
		sind=0;
		i3=0;
		//Вывести талон на lcd
		lcd_add_line(sLineBuffer);
	}
}

__bit wActive;
__bit wBusy;
__bit wDeclineBtn;
__bit clIsWaiting;

// Прерывание int1, Обработать действие оператора
void btn_pressed() __interrupt(2)
{
	//дребезг контактов начало
		lcd_delay();
		IE1=0;
	//дребезг конец
	keyCode = P1 & 0x0F;
	wDeclineBtn = keyCode & 0x08; // Нажата кнопка отменить
	keyCode &= 0x07;			  // преобразование в id рабочего места
	wActive = WisActive(keyCode); // рабочее место активно
	if(!wActive) return;

	wBusy = WisBusy(keyCode);     // Рабочее место занято
	clIsWaiting = queue_find(0, WgetCatID(keyCode), 0); //в очереди есть клиент в ожидании
	
	if(!wBusy && !wDeclineBtn && clIsWaiting)
	{
		// Добавить id рабочего места к позиции в очереди
		// Сменить статус у текущей позиции в очереди на В обработке
		QueueTable.el[i1].info = (keyCode << 5) | ( (WgetCatID(keyCode))<<2 ) | 0x01;

		//Позвать клиента
		if(clCallMethod){
			lcd_print_first_four_clients();//Вызвать можно до 4 клиентов одновременно (кол-во строк в lcd)
		}else{
			lcd_client_call(i1,keyCode);
		}

		//Установить статус Занят
		WorkerTable[ keyCode ] |= 0b01000000;

		//зажечь индикатор занятости
		led_busy_up(keyCode);

		//Погасить лампы когда больше нет ожидающих клиентов
		if( !queue_find(0, WgetCatID(keyCode), 0) )
		{
			LEDmask = LEDreg;
			find_all_workers(WgetCatID(keyCode));//Для каждого найденного рабочего места в категории
			for (i1=0; i1 < i2; i1++)
			{
				LEDmask |= ~( LEDgetMask(Res[i1]) ); // погасить лампу 
			}
			LED_reload(LEDmask,0);
		}
		return;
	}
	if(!wBusy) return;
	
	//Работник обрабатывает заявку
	queue_find( keyCode, WgetCatID(keyCode), 1);
	QueueTable.el[i1].info += wDeclineBtn ? 2 : 1; // поставить статус "отменено"/"обработано"

	// Обновить список вызовов, с учетом обработаного клиента в случае метода с задержкой
	if(clCallMethod){
		lcdLineNum--;// если lcdLineNum == 4 то вычитание 1 позволит запустить метод lcd_print_first_four_clients(). Теперь след клиенты будут вызваны.
		lcd_print_first_four_clients();
	}

	WorkerTable[ keyCode ] &= 0b10111111; // установить статус свободен у рабочего места
	// Погасить лампу
	led_busy_down(keyCode);

	// Если нет клиентов в очереди, то
	if(!clIsWaiting)
	{
		LEDmask = LEDreg;
		find_all_workers(WgetCatID(keyCode));// для каждого найденного рабочего места в категории
		for (i1=0; i1 < i2; i1++)
		{
			LEDmask |= ~( LEDgetMask(Res[i1]) ); // погасить лампу 
		}
		LED_reload(LEDmask,0);
	}
}

//Прерывание от uart, функции:
// Зарегистрировать клиента и выбранную им категорию услуги в очереди
void service() __interrupt(4)
{
	TI = 0;
	RI = 0;
	switch (KA)
	{
// Регистрация клиентов в очереди
	case WELCOME://отправка строки-приветствия-клиентов
		vt_print(sWelcome, PRINTSERVICES, 1);
		break;
	case PRINTSERVICES:
		TI=1;
		vt_write_categories();
		putchar('\r');
		putstring(sEnterCat);
		while (!TI);//Отлов последнего бита который придет после последнего putchar()
		TI=0;
		KA=F;
		break;
	case F:// Клиент ввел категорию
		{
			vt_read(vtin);
			vtin-=0x30;		  //перевод символа в int
			if( vtin<0 || vtin>7 || !(CgetName(vtin)))//Введено не число или отсутствующая категория
			{
				KA=WRONGNUMBER;//Wrong Number! 
				RI=1;
				return;
			}
			register_in_queue(vtin);		  //Зарегистрировать участника категории
			
			LEDmask = LEDreg; //Маска будет изменять текущее состояние ламп
			
			find_all_workers(vtin);//Для каждого найденного рабочего места в категории
			for (i1=0; i1 < i2; i1++)
			{
				LEDmask &=LEDgetMask(Res[i1]); //Зажечь лампу 
			}	
			
			LED_reload(LEDmask,0);	

			//Определить выводимый Клиентский идентификатор позиции в очереди. В elem содержится информация о добавленом клиенте
			queue_elem_to_ascii( elem.info, elem.num);

			KA=YNUMIS;//Программный вызов прерывания
			RI=1; 
		}
		break;
	case YNUMIS://Вывод фразы You num is...
	    vt_print(sYNumIs, CLIENTNUM, 1);
		break;
	case CLIENTNUM://Вывод номера после фразы YNUMIS
		vt_print(sLineBuffer, CLIENTACK, 0);
		break;
	case CLIENTACK:	//После подтверждения номера клиентом терминал будет сброшен
		TI=1;
		vt_clrscr();
		TI=0;
		KA=WELCOME;
		break;
	case WRONGNUMBER://Вывод сообщения после выбора неверного номера 
		vt_print(sWrongNum,CLIENTACK,0);
		break;
	}
}